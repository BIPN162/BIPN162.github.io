---
redirect_from:
  - "/singlecell/celltypes"
interact_link: content/singlecell/CellTypes.ipynb
kernel_name: python3
kernel_path: content/singlecell
has_widgets: false
title: |-
  Allen Cell Types
pagenum: 6
prev_page:
  url: /singlecell/singlecell_home.html
next_page:
  url: /ISH/ISH_home.html
suffix: .ipynb
search: dataframe pandas method information our get cells columns data cell column join types allensdk href assign output merge well metadata humandf using dataframes database celltypescache need rows ephysfeatures confirm allen take youre documentation core io order step where into pydata org docs stable lets reassign values id different electrophysiology unique above module manifest create file contains cache readthedocs en latest htmlhere below installed already getcells human humancells convert pd help len alternatively count just observations might length nhumancells any list indices execute index words across accessing attribute notation name boolean filter dendrite originaldf interest desired value original equal its electrophysiological

comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---

    <main class="jupyter-page">
    <div id="page-info"><div id="page-title">Allen Cell Types</div>
</div>
    
<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Allen-Cell-Types-Database">Allen Cell Types Database<a class="anchor-link" href="#Allen-Cell-Types-Database"> </a></h1><p>This notebook will serve as an introduction to the Allen Cell Types database. We'll work with the AllenSDK to see what information we can gain about our cells.</p>
<p>First, we'll <code>import</code> the CellTypesCache module. This module provides tools to allow us to get information from the cell types database. We're giving it a <strong>manifest</strong> filename as well. CellTypesCache will create this manifest file, which contains metadata about the cache. You can look under cell_types in your directory, and take a look at the file.</p>
<p>(If you're curious you can see the full documentation for the core package <a href="https://allensdk.readthedocs.io/en/latest/allensdk.core.html">here</a>.)</p>
<p><b>Note</b>: In order to run the line below, you need to have the AllenSDK installed. You can find information on how to do that <a href="http://alleninstitute.github.io/AllenSDK/install.html">here</a>. If you're running this on the UCSD Datahub, the Allen SDK has already been installed for you.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#Import the &quot;Cell Types Cache&quot; from the AllenSDK core package</span>
<span class="kn">from</span> <span class="nn">allensdk.core.cell_types_cache</span> <span class="k">import</span> <span class="n">CellTypesCache</span>

<span class="c1">#Import CellTypesApi, which will allow us to query the database.</span>
<span class="kn">from</span> <span class="nn">allensdk.api.queries.cell_types_api</span> <span class="k">import</span> <span class="n">CellTypesApi</span>

<span class="c1"># We&#39;ll then initialize the cache as &#39;ctc&#39; (cell types cache)</span>
<span class="n">ctc</span> <span class="o">=</span> <span class="n">CellTypesCache</span><span class="p">(</span><span class="n">manifest_file</span><span class="o">=</span><span class="s1">&#39;cell_types/manifest.json&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Step-One:-Get-Cells-&amp;-Manipulate-Dataframe">Step One: Get Cells &amp; Manipulate Dataframe<a class="anchor-link" href="#Step-One:-Get-Cells-&amp;-Manipulate-Dataframe"> </a></h2><p>Look through <a href="https://allensdk.readthedocs.io/en/latest/allensdk.core.cell_types_cache.html">the documentation for the CellTypesCache</a> for information on the <code>get_cells</code> method.</p>
<p>Use the get_cells method in the cell below to get information about all of the human cells in the database. Assign the output of this to <code>human_cells</code>, and look at the output when it is done.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Chances are, your output looks a bit messy. This is where pandas can really come in handy! Convert <code>human_cells</code> into a Pandas Dataframe by:</p>
<ol>
<li>Importing <code>pandas</code> as <code>pd</code></li>
<li>Creating a dataframe with <code>pd.DataFrame()</code></li>
<li>Assigning that dataframe to <code>human_df</code></li>
<li>Showing the first five rows of the df using the <code>.head()</code> method.</li>
</ol>
<p>Note: If you're having trouble with Pandas, it can help to look at <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/">the user guide</a>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's get some information about our cells. We can use <code>len()</code> on a dataframe to get the number of rows. Alternatively, we can use the <code>count()</code> method on our dataframe to get detailed information for each column. For our purposes today, let's just get the number of rows, which is equivalent to the number of observations.</p>
<ol>
<li>Use the <code>count()</code> method to see how many observations there are in each of the columns. Why might some be missing?</li>
<li>Use <code>len()</code> to see the length of the whole dataframe and assign the output to <code>n_human_cells</code>.</li>
</ol>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>At the moment, our rows don't have any useful information -- they're simply a list of indices. We can reassign the row values by using the method <code>set_index</code>. Execute this method to set the 'id' column as the index, and reassign your dataframe as <code>human_df</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">human_df</span> <span class="o">=</span> 
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It would help to know what information is in our dataset. In other words, what is across the columns at the top? We can get a list by accessing the attribute <code>.columns</code>. Assign the output of this method to <code>human_df_columns</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">human_df_columns</span> <span class="o">=</span> 
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can access individual columns with the notation <code>dataframe['column name']</code>. Check out the <code>dendrite_type</code> column by using this notation.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Like numpy arrays, we can use boolean indexing to filter our pandas dataframe. Our dataframe has data on two different dendrite types. Filter your dataframe by using the following syntax:</p>

<pre><code>new_df = original_df[original_df['Column of Interest'] == 'Desired Value']</code></pre>
<p>In plain english, what this is saying is: save a dataframe from the original dataframe, where the original dataframe values in my Column of Interest are equal to my Desired Value.</p>
<ol>
<li>Assign your new dataframe and give it a reasonable name (e.g., <code>spiny_df</code>)</li>
<li>Create a second dataframe for the <em>other</em> dendrite type.</li>
</ol>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Step-Two:-Get-Electrophysiology-Data">Step Two: Get Electrophysiology Data<a class="anchor-link" href="#Step-Two:-Get-Electrophysiology-Data"> </a></h2><p>At this point, you might have realized that this dataframe doesn't contain any data about the electrophysiology -- it's just metadata about the cells. In order to get information about the electrophysiological properties of these cells, we need to use the <code>get_ephys_features()</code> method on our instance of the cell types cache.</p>
<ol>
<li>Execute the <code>get_ephys_features</code> method on our cell types instance and assign the output of this to <code>ephys_features</code>.</li>
<li>Convert <code>ephys_features</code> into a pandas dataframe.</li>
<li>Re-assign the index to be the column labeled 'specimen_id' of the cell (and reassign to <code>ephys_features</code>). 'specimen_id' is the label that can link this dataframe to our metadata (human_df) dataframe.</li>
</ol>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we have two dataframes, one with the metadata for human cells (indexed by id) and another with the electrophysiology data for all cells, also indexed by id. Usefully, these ids are unique to each cell, meaning we can match them across dataframes.</p>
<p>We can use either the <code>merge</code> or <code>join</code> pandas methods in order to pull all of this data into one dataframe.</p>
<p><img src="http://www.datasciencemadesimple.com/wp-content/uploads/2017/09/join-or-merge-in-python-pandas-1.png" alt=""></p>
<p>There are different types of joins/merges you can do in pandas, illustrated <a href="http://www.datasciencemadesimple.com/join-merge-data-frames-pandas-python/">above</a>. Here, we want to do an <strong>inner</strong> merge, where we're only keeping entries with indices that are in both dataframes. We could do this merge based on columns, alternatively.</p>
<p><strong>Inner</strong> is the default kind of join, so we do not need to specify it. And by default, join will use the 'left' dataframe, in other words, the dataframe that is executing the <code>join</code> method.</p>
<p>If you need more information, look at the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.join.html">join</a> and <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html">merge</a> documentation: you can use either of these to unite your dataframes, though join will be simpler!</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Step-Three:-Confirm-the-data-and-take-a-look!">Step Three: Confirm the data and take a look!<a class="anchor-link" href="#Step-Three:-Confirm-the-data-and-take-a-look!"> </a></h2><p>As a result, you should have a dataframe called 'human_ephys_features' that contains metadata about your cells, as well as their electrophysiological properties.</p>
<ol>
<li>Confirm that you have right amount of data by checking it's length using a Boolean to test whether it is equal to <code>n_human_cells</code> that you assigned above.</li>
<li>Confirm that you have all of the columns from <em>both</em> the human_df and ephys_features dataframes programmatically. Remember that you can get the columns by accessing the <code>columns</code> attribute, and that you already assigned the human_df columns to a variable above. There are a few different ways to do this!</li>
<li>Confirm that the only 'species' in your <code>human_ephys_features</code> dataframe is 'Homo Sapiens'. You can use the <code>unique()</code> method to show unique values in a column.</li>
</ol>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Finally</em>, let's take a look at the data. You can use the <code>describe()</code> method to show the basic statistics for your cells. We'll start plotting these metrics next week!</p>

</div>
</div>
</div>
</div>

 


    </main>
    